# -*- coding: utf-8 -*-
"""A1 HW1 CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12pkc2HYRi8JNi2YoGbhjD2h51S8_zk6N
"""

from collections import deque
import time
import matplotlib.pyplot as plt

def graphSearch(initial_node, is_goal, successors_fn, search_type, depth_limit=None):
    if search_type == "bf":
        return breadth_first_search(initial_node, is_goal, successors_fn)
    elif search_type == "df":
        return depth_first_search(initial_node, is_goal, successors_fn)
    elif search_type == "id":
        return iterative_deepening_search(initial_node, is_goal, successors_fn)
    elif search_type == "bd":
        return bidirectional_search(initial_node, is_goal, successors_fn)
    elif search_type == "dls":
        return depth_limited_search(initial_node, is_goal, successors_fn, depth_limit)
    else:
        raise ValueError("Invalid search type. Supported types are: bf, df, id, bd, dls")

def breadth_first_search(initial_node, is_goal, successors_fn):
    queue = deque([(initial_node, [])])

    while queue:
        node, path = queue.popleft()
        if is_goal(node):
            return path + [node]
        for successor in successors_fn(node):
            if successor not in path:
                queue.append((successor, path + [node]))

    return None

def depth_first_search(initial_node, is_goal, successors_fn):
    stack = [(initial_node, [])]

    while stack:
        node, path = stack.pop()
        if is_goal(node):
            return path + [node]
        for successor in successors_fn(node):
            if successor not in path:
                stack.append((successor, path + [node]))

    return None

def iterative_deepening_search(initial_node, is_goal, successors_fn):
    depth_limit = 1
    while True:
        result = depth_limited_search(initial_node, is_goal, successors_fn, depth_limit)
        if result is not None:
            return result
        depth_limit += 1

def depth_limited_search(node, is_goal, successors_fn, depth_limit, path=[]):
    if depth_limit == 0:
        return None
    if is_goal(node):
        return path + [node]
    for successor in successors_fn(node):
        if successor not in path:
            result = depth_limited_search(successor, is_goal, successors_fn, depth_limit - 1, path + [node])
            if result is not None:
                return result
    return None

def bidirectional_search(initial_node, is_goal, successors_fn):
    forward_queue = deque([(initial_node, [])])
    backward_queue = deque([(goal_state, [])])  # Start from the goal state for backward search
    forward_visited = {tuple(map(tuple, initial_node))}
    backward_visited = {tuple(map(tuple, goal_state))}

    while forward_queue and backward_queue:  # Add condition for both queues being non-empty
        # Forward search
        if forward_queue:
            node, path = forward_queue.popleft()
            forward_visited.add(tuple(map(tuple, node)))
            if tuple(map(tuple, node)) in backward_visited:
                return path + [node] + backward_queue[list(backward_visited).index(tuple(map(tuple, node)))][1][::-1]
            for successor in successors_fn(node, "forward"):  # Pass "forward" as the direction
                if tuple(map(tuple, successor)) not in forward_visited:
                    forward_queue.append((successor, path + [node]))

        # Backward search
        if backward_queue:
            node, path = backward_queue.popleft()
            backward_visited.add(tuple(map(tuple, node)))
            if tuple(map(tuple, node)) in forward_visited:
                return path[::-1] + [node] + forward_queue[list(forward_visited).index(tuple(map(tuple, node)))][1]
            for predecessor in successors_fn(node, "backward"):  # Pass "backward" as the direction
                if tuple(map(tuple, predecessor)) not in backward_visited:
                    backward_queue.append((predecessor, path + [node]))

    return None

"""BFS nPuzzle"""

from collections import deque
import time

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row.copy() for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using BFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "bf")
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

# Example usage:
initial_state = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]
solution_path, execution_time = solve_n_puzzle(initial_state)
# print("Solution Path:")
# for state in solution_path:
#     print(state)

print("Execution Time:", execution_time, "seconds")

from collections import deque
import time
import matplotlib.pyplot as plt

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_tile_position = find_empty_tile(state)
    if empty_tile_position is None:
        return successors

    empty_row, empty_col = empty_tile_position
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row.copy() for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j
    return None

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using BFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "bf")
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

def plot_theoretical_time(n, theoretical_time):
    """Plot the theoretical time complexity."""
    plt.plot(n, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of BFS for n-Puzzle')
    plt.grid(True)
    plt.show()

def plot_execution_time(n, execution_time):
    """Plot the practical execution time."""
    plt.plot(n, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of BFS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Example usage:
n_values = [3, 4, 5, 6, 7, 8,9 ,10, 11, 12, 13, 14, 15]  # Example sizes of puzzles
theoretical_time = []  # List to store theoretical time
execution_time = []  # List to store execution time

for n in n_values:
    initial_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]  # Generate initial state for each n
    solution_path, exec_time = solve_n_puzzle(initial_state)
    theoretical_time.append(n ** 2)  # Assuming O(n^2) time complexity for BFS
    execution_time.append(exec_time)

plot_theoretical_time(n_values, theoretical_time)
plot_execution_time(n_values, execution_time)

from collections import deque
import time

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row.copy() for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using BFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "id")
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

# Example usage:
initial_state_4x4 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 0]  # 0 represents the empty tile
]
solution_path_4x4, execution_time_4x4 = solve_n_puzzle(initial_state_4x4)
print("Solution Path:")
for state in solution_path_4x4:
    print(state)

print("Execution Time:", execution_time_4x4, "seconds")

ID nPuzzle

from collections import deque
import time

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row.copy() for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using BFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "id")
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

# Example usage:
initial_state = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]
solution_path, execution_time = solve_n_puzzle(initial_state)
# print("Solution Path:")
# for state in solution_path:
#     print(state)

print("Execution Time:", execution_time, "seconds")

from collections import deque
import time
import matplotlib.pyplot as plt
import random

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j
    raise ValueError("Empty tile not found in the initial state.")

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using BFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "id")
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

# Example usage:
initial_state = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]

# Function to generate a random initial state with a solvable configuration
def generate_initial_state(state):
    return state

# Example usage:
n_values = [3, 4, 5, 6]  # Example sizes of puzzles
theoretical_time = []  # List to store theoretical time
execution_time = []  # List to store execution time

for n in n_values:
    initial_state = generate_initial_state(initial_state)

    solution_path, exec_time = solve_n_puzzle(initial_state)
    theoretical_time.append(n ** 2)  # Assuming O(n^2) time complexity for Iterative Deepening
    execution_time.append(exec_time)

# Plotting
def plot_theoretical_time(n_values, theoretical_time):
    """Plot the theoretical time complexity."""
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of Iterative Deepening for n-Puzzle')
    plt.grid(True)
    plt.show()

def plot_execution_time(n_values, execution_time):
    """Plot the practical execution time."""
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of Iterative Deepening for n-Puzzle')
    plt.grid(True)
    plt.show()

plot_theoretical_time(n_values, theoretical_time)
plot_execution_time(n_values, execution_time)

"""DFS without limit takes forever to run

DFS nPuzzle with limit executes and provides results.
"""

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row.copy() for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the n-Puzzle problem using DFS."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, "dls", depth_limit=50)  # Adjust the depth limit as needed
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time


    # Example usage:
initial_state = [
    [1, 2, 3],
    [4, 0, 5],
    [6, 7, 8]
]
solution_path, execution_time = solve_n_puzzle(initial_state)
# print("Solution Path:")
# for state in solution_path:
#     print(state)

print("Execution Time:", execution_time, "seconds")

from collections import deque
import time
import matplotlib.pyplot as plt
import random

def is_goal(state):
    """Check if the given state is the goal state."""
    n = len(state)
    goal_state = [[j*n + i + 1 for i in range(n)] for j in range(n)]
    goal_state[-1][-1] = 0  # Empty tile represented by 0
    return state == goal_state

def successors_fn(state):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < len(state) and 0 <= new_col < len(state):
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i, row in enumerate(state):
        for j, tile in enumerate(row):
            if tile == 0:
                return i, j
    raise ValueError("Empty tile not found in the initial state.")

def solve_n_puzzle(initial_state, algorithm, depth_limit=None):
    """Solve the n-Puzzle problem using the specified algorithm."""
    start_time = time.time()
    solution = graphSearch(initial_state, is_goal, successors_fn, algorithm, depth_limit=depth_limit)
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

# Function to plot theoretical time complexity of DLS
def plot_theoretical_time_dls(n_values, theoretical_time):
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of DLS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Function to plot practical execution time of DLS
def plot_execution_time_dls(n_values, execution_time):
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of DLS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Example usage:
n_values = [3, 4, 5, 6]  # Example sizes of puzzles
theoretical_time_dls = []  # List to store theoretical time
execution_time_dls = []  # List to store execution time

for n in n_values:
    initial_state = [
        [1, 3, 2],
        [5, 0, 4],
        [6, 7, 8]
    ]  # Initial state provided
    solution_path, exec_time = solve_n_puzzle(initial_state, "dls", depth_limit=50)  # Adjust the depth limit as needed
    theoretical_time_dls.append(n ** 2)  # Assuming O(n^2) time complexity for DLS
    execution_time_dls.append(exec_time)

plot_theoretical_time_dls(n_values, theoretical_time_dls)
plot_execution_time_dls(n_values, execution_time_dls)

"""Bi Directional nPuzzle"""

from collections import deque
import time
import random

def is_goal(state):
    """Check if the given state is the goal state."""
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    return state == goal_state

def successors_fn_forward(state):
    """Generate successor states for the given state in forward direction."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def successors_fn_backward(state):
    """Generate successor states for the given state in backward direction."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row - dir_row, empty_col - dir_col
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the 8-puzzle problem using Bidirectional BFS."""
    start_time = time.time()
    solution = bidirectional_search(initial_state, is_goal, successors_fn_forward, successors_fn_backward)
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

def bidirectional_search(initial_state, is_goal, successors_fn_forward, successors_fn_backward):
    forward_queue = deque([(initial_state, [])])
    backward_queue = deque([(goal_state, [])])  # Start from the goal state for backward search
    forward_visited = {tuple(map(tuple, initial_state))}
    backward_visited = {tuple(map(tuple, goal_state))}

    print("Initial State:")
    print(initial_state)

    while forward_queue and backward_queue:
        # Forward search
        node, path = forward_queue.popleft()
        print("Forward Node:")
        print(node)
        if is_goal(node):
            print("Goal reached")
            return path + [node]
        for successor in successors_fn_forward(node):
            if tuple(map(tuple, successor)) not in forward_visited:
                forward_queue.append((successor, path + [node]))
                forward_visited.add(tuple(map(tuple, successor)))

        # Backward search
        node, path = backward_queue.popleft()
        print("Backward Node:")
        print(node)
        if is_goal(node):
            print("Goal reached")
            return path[::-1] + [node]
        for predecessor in successors_fn_backward(node):
            if tuple(map(tuple, predecessor)) not in backward_visited:
                backward_queue.append((predecessor, path + [node]))
                backward_visited.add(tuple(map(tuple, predecessor)))

    return None


# Generate a solvable initial state
initial_state = [
    [1, 3, 4],
    [8, 6, 2],
    [7, 0, 5]
]

# Solve the 8-puzzle problem
solution_path, execution_time = solve_n_puzzle(initial_state)

# Print the solution path and execution time
# if solution_path:
#     print("Solution Path:")
#     for state in solution_path:
#         print(state)
#     print("Execution Time:", execution_time, "seconds")
# else:
#     print("No solution found.")

from collections import deque
import time
import matplotlib.pyplot as plt

def is_goal(state):
    """Check if the given state is the goal state."""
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    return state == goal_state

def successors_fn_forward(state):
    """Generate successor states for the given state in forward direction."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def successors_fn_backward(state):
    """Generate successor states for the given state in backward direction."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row - dir_row, empty_col - dir_col
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the 8-puzzle problem using Bidirectional BFS."""
    start_time = time.time()
    solution = bidirectional_search(initial_state, is_goal, successors_fn_forward, successors_fn_backward)
    end_time = time.time()
    execution_time = end_time - start_time
    return solution, execution_time

def bidirectional_search(initial_state, is_goal, successors_fn_forward, successors_fn_backward):
    forward_queue = deque([(initial_state, [])])
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]  # Define goal state here
    backward_queue = deque([(goal_state, [])])  # Start from the goal state for backward search
    forward_visited = {tuple(map(tuple, initial_state))}
    backward_visited = {tuple(map(tuple, goal_state))}

    while forward_queue and backward_queue:
        # Forward search
        node, path = forward_queue.popleft()
        if is_goal(node):
            return path + [node]
        for successor in successors_fn_forward(node):
            if tuple(map(tuple, successor)) not in forward_visited:
                forward_queue.append((successor, path + [node]))
                forward_visited.add(tuple(map(tuple, successor)))

        # Backward search
        node, path = backward_queue.popleft()
        if is_goal(node):
            return path[::-1] + [node]
        for predecessor in successors_fn_backward(node):
            if tuple(map(tuple, predecessor)) not in backward_visited:
                backward_queue.append((predecessor, path + [node]))
                backward_visited.add(tuple(map(tuple, predecessor)))

    return None

# Function to plot theoretical time complexity of Bidirectional BFS
def plot_theoretical_time_bds(n_values, theoretical_time):
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of Bi-directional BFS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Function to plot practical execution time of Bidirectional BFS
def plot_execution_time_bds(n_values, execution_time):
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of Bi-directional BFS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Example usage:
n_values = [3, 4, 5, 6]  # Example sizes of puzzles
theoretical_time_bds = []  # List to store theoretical time
execution_time_bds = []  # List to store execution time

for n in n_values:
    initial_state = [
        [1, 3, 4],
        [8, 6, 2],
        [7, 0, 5]
    ]  # Initial state provided
    solution_path, exec_time = solve_n_puzzle(initial_state)
    theoretical_time_bds.append(n ** 2)  # Assuming O(n^2) time complexity for Bi-directional BFS
    execution_time_bds.append(exec_time)

plot_theoretical_time_bds(n_values, theoretical_time_bds)
plot_execution_time_bds(n_values, execution_time_bds)

from collections import deque

def graphSearch(initial_node, is_goal, successors_fn, search_type, depth_limit=None):
    if search_type == "bf":
        return breadth_first_search(initial_node, is_goal, successors_fn)
    elif search_type == "df":
        return depth_first_search(initial_node, is_goal, successors_fn)
    elif search_type == "id":
        return iterative_deepening_search(initial_node, is_goal, successors_fn)
    elif search_type == "bd":
        return bidirectional_search(initial_node, is_goal, successors_fn)
    elif search_type == "dls":
        return depth_limited_search(initial_node, is_goal, successors_fn, depth_limit)
    else:
        raise ValueError("Invalid search type. Supported types are: bf, df, id, bd, dls")

def breadth_first_search(initial_node, is_goal, successors_fn):
    queue = deque([(initial_node, [])])

    while queue:
        node, path = queue.popleft()
        if is_goal(node):
            return path + [node]
        for successor in successors_fn(node):
            if successor not in path:
                queue.append((successor, path + [node]))

    return None

def depth_first_search(initial_node, is_goal, successors_fn):
    stack = [(initial_node, [])]

    while stack:
        node, path = stack.pop()
        if is_goal(node):
            return path + [node]
        for successor in successors_fn(node):
            if successor not in path:
                stack.append((successor, path + [node]))

    return None

def iterative_deepening_search(initial_node, is_goal, successors_fn):
    depth_limit = 1
    while True:
        result = depth_limited_search(initial_node, is_goal, successors_fn, depth_limit)
        if result is not None:
            return result
        depth_limit += 1

def depth_limited_search(node, is_goal, successors_fn, depth_limit, path=[]):
    if depth_limit == 0:
        return None
    if is_goal(node):
        return path + [node]
    for successor in successors_fn(node):
        if successor not in path:
            result = depth_limited_search(successor, is_goal, successors_fn, depth_limit - 1, path + [node])
            if result is not None:
                return result
    return None

def bidirectional_search(initial_node, is_goal, successors_fn):
    forward_queue = deque([(initial_node, [])])
    backward_queue = deque([(goal_state, [])])  # Start from the goal state for backward search
    forward_visited = {tuple(map(tuple, initial_node))}
    backward_visited = {tuple(map(tuple, goal_state))}

    while forward_queue and backward_queue:  # Add condition for both queues being non-empty
        # Forward search
        if forward_queue:
            node, path = forward_queue.popleft()
            forward_visited.add(tuple(map(tuple, node)))
            if tuple(map(tuple, node)) in backward_visited:
                return path + [node] + backward_queue[list(backward_visited).index(tuple(map(tuple, node)))][1][::-1]
            for successor in successors_fn(node, "forward"):  # Pass "forward" as the direction
                if tuple(map(tuple, successor)) not in forward_visited:
                    forward_queue.append((successor, path + [node]))

        # Backward search
        if backward_queue:
            node, path = backward_queue.popleft()
            backward_visited.add(tuple(map(tuple, node)))
            if tuple(map(tuple, node)) in forward_visited:
                return path[::-1] + [node] + forward_queue[list(forward_visited).index(tuple(map(tuple, node)))][1]
            for predecessor in successors_fn(node, "backward"):  # Pass "backward" as the direction
                if tuple(map(tuple, predecessor)) not in backward_visited:
                    backward_queue.append((predecessor, path + [node]))

    return None


def is_goal(state):
    """Check if the given state is the goal state."""
    goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]
    return state == goal_state

def successors_fn(state, direction):
    """Generate successor states for the given state."""
    successors = []
    empty_row, empty_col = find_empty_tile(state)
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    for dir_row, dir_col in directions:
        new_row, new_col = empty_row + dir_row, empty_col + dir_col
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            successor = [row[:] for row in state]
            successor[empty_row][empty_col], successor[new_row][new_col] = \
                successor[new_row][new_col], successor[empty_row][empty_col]
            successors.append(successor)

    if direction == "backward":
        successors.reverse()  # Reverse the order of successors for backward search

    return successors

def find_empty_tile(state):
    """Find the position of the empty tile in the given state."""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def solve_n_puzzle(initial_state):
    """Solve the 8-puzzle problem using BD."""
    solution = graphSearch(initial_state, is_goal, successors_fn, "bd", 2)
    return solution

# Example usage:
initial_state = [
    [1, 3, 2],
    [4, 6, 5],
    [7, 8, 0]
]
solution_path = solve_n_puzzle(initial_state)
if solution_path:
    print("Solution Path:")
    for state in solution_path:
        print(state)
    print("Execution Time:", execution_time, "seconds")
else:
    print("No solution found.")

"""BFS nQueens"""

from collections import deque
import time

def is_safe(board, row, col, n):
    # Check if there is a queen in the same column or diagonal
    for i in range(row):
        if board[i] == col or abs(row - i) == abs(col - board[i]):
            return False
    return True

def successors_fn(state, n):
    row = len(state)
    successors = []
    for col in range(n):
        if is_safe(state, row, col, n):
            successors.append(state + [col])  # Append the column to the state
    return successors

def is_goal(state, n):
    return len(state) == n

def bfs(initial_state, n):
    solutions = []
    queue = deque([(initial_state, [])])

    while queue:
        node, path = queue.popleft()
        if is_goal(node, n):
            solutions.append(path + [node])
        else:
            for successor in successors_fn(node, n):
                queue.append((successor, path + [node]))

    return solutions

def solve_n_queens(n):
    initial_state = []
    start_time = time.time()
    solutions = bfs(initial_state, n)
    end_time = time.time()
    execution_time = end_time - start_time
    return solutions, execution_time

# Example usage:
n = 5
solutions, execution_time = solve_n_queens(n)
if solutions:
    print(f"Total solutions for {n}-queens problem: {len(solutions)}")
    for i, solution in enumerate(solutions):
        print(f"\nSolution {i+1}:")
        for col in solution[-1]:
            row_representation = ['Q' if c == col else '.' for c in range(n)]
            print(" ".join(row_representation))
else:
    print("No solution found.")

print("Execution Time:", execution_time, "seconds")

# Function to calculate theoretical time complexity of BFS for n-Puzzle
def theoretical_time_complexity_bfs(n_values):
    theoretical_time = []
    for n in n_values:
        # Theoretical time complexity calculation, adjust as needed
        theoretical_time.append(n ** 3)  # Example: O(n^3)
    return theoretical_time

# Function to plot theoretical time complexity of BFS for n-Puzzle
def plot_theoretical_time_complexity(n_values, theoretical_time):
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of BFS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Function to plot practical execution time of BFS for n-Queens
def plot_practical_execution_time(n_values, execution_time):
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Queens Board)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of BFS for n-Queens')
    plt.grid(True)
    plt.show()

# Example usage:
# Define the range of values for n
n_values = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]  # Example sizes of puzzles or boards
theoretical_time_bfs = theoretical_time_complexity_bfs(n_values)  # Theoretical time complexity
execution_time_bfs = [0.1, 0.3, 0.5, 1.2, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5]  # Example execution time for n-Queens, adjust as needed

# Plotting theoretical time complexity of BFS for n-Puzzle
plot_theoretical_time_complexity(n_values, theoretical_time_bfs)

# Plotting practical execution time of BFS for n-Queens
plot_practical_execution_time(n_values, execution_time_bfs)

"""DFS nQueens"""

import time

def is_safe(board, row, col, n):
    # Check if there is a queen in the same column or diagonal
    for i in range(row):
        if board[i] == col or abs(row - i) == abs(col - board[i]):
            return False
    return True

def successors_fn(state, n):
    row = len(state)
    successors = []
    for col in range(n):
        if is_safe(state, row, col, n):
            successors.append(state + [col])  # Append the column to the state
    return successors

def is_goal(state, n):
    return len(state) == n

def dfs(initial_state, n):
    solutions = []
    stack = [(initial_state, [])]

    while stack:
        node, path = stack.pop()
        if is_goal(node, n):
            solutions.append(path + [node])
        else:
            for successor in successors_fn(node, n):
                stack.append((successor, path + [node]))

    return solutions

def solve_n_queens(n):
    initial_state = []
    start_time = time.time()
    solutions = dfs(initial_state, n)
    end_time = time.time()
    execution_time = end_time - start_time
    return solutions, execution_time

# Example usage:
n = 5
solutions, execution_time = solve_n_queens(n)
if solutions:
    print(f"Total solutions for {n}-queens problem: {len(solutions)}")
    for i, solution in enumerate(solutions):
        print(f"\nSolution {i+1}:")
        for col in solution[-1]:
            row_representation = ['Q' if c == col else '.' for c in range(n)]
            print(" ".join(row_representation))
else:
    print("No solution found.")

print("Execution Time:", execution_time, "seconds")


# Function to calculate theoretical time complexity of DFS for n-Puzzle
def theoretical_time_complexity_dfs(n_values):
    theoretical_time = []
    for n in n_values:
        # Theoretical time complexity calculation, adjust as needed
        theoretical_time.append(n ** 3)  # Example: O(n^3)
    return theoretical_time

# Function to plot theoretical time complexity of DFS for n-Puzzle
def plot_theoretical_time_complexity(n_values, theoretical_time):
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of DFS for n-Puzzle')
    plt.grid(True)
    plt.show()

# Function to plot practical execution time of DFS for n-Queens
def plot_practical_execution_time(n_values, execution_time):
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Queens Board)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of DFS for n-Queens')
    plt.grid(True)
    plt.show()

# Example usage:
# Define the range of values for n
n_values = [4, 5, 6, 7, 8]  # Example sizes of puzzles or boards
theoretical_time_dfs = theoretical_time_complexity_dfs(n_values)  # Theoretical time complexity
execution_time_dfs = [0.1, 0.3, 0.5, 1.2, 2.5]  # Example execution time for n-Queens, adjust as needed

# Plotting theoretical time complexity of DFS for n-Puzzle
plot_theoretical_time_complexity(n_values, theoretical_time_dfs)

# Plotting practical execution time of DFS for n-Queens
plot_practical_execution_time(n_values, execution_time_dfs)

"""ID nQueens"""

import time

def is_safe(board, row, col):
    # Check if there is a queen in the same column or diagonal
    for r, c in enumerate(board):
        if c == col or abs(row - r) == abs(col - c):
            return False
    return True

def successors_fn(state, n):
    row = len(state)
    successors = []
    for col in range(n):
        if is_safe(state, row, col):
            successors.append(state + [col])  # Append the column to the state
    return successors

def dfs_max_depth(initial_state, max_depth, n):
    stack = [(initial_state, 0)]
    solutions = []
    while stack:
        node, depth = stack.pop()
        if depth > max_depth:
            continue
        if len(node) == n:
            solutions.append(node)
        for successor in successors_fn(node, n):
            stack.append((successor, depth + 1))
    return solutions

def solve_n_queens_ids(n):
    start_time = time.time()
    all_solutions = []
    for depth in range(n + 1):  # Allow searching up to n queens
        initial_state = []
        solutions = dfs_max_depth(initial_state, depth, n)
        all_solutions.extend(solutions)
    end_time = time.time()
    execution_time = end_time - start_time
    return all_solutions, execution_time

# Example usage:
n = 5
solutions, execution_time = solve_n_queens_ids(n)
if solutions:
    print(f"Total solutions for {n}-queens problem: {len(solutions)}")
    for i, solution in enumerate(solutions):
        print(f"\nSolution {i + 1}:")
        for col in solution:
            row_representation = ['Q' if c == col else '.' for c in range(n)]
            print(" ".join(row_representation))
else:
    print("No solution found.")

print("Execution Time:", execution_time, "seconds")

# Function to calculate theoretical time complexity of ID for n-Puzzle
def theoretical_time_complexity_id(n_values):
    theoretical_time = []
    for n in n_values:
        # Theoretical time complexity calculation, adjust as needed
        theoretical_time.append(n ** 4)  # Example: O(n^4)
    return theoretical_time

# Function to plot theoretical time complexity of ID for n-Puzzle
def plot_theoretical_time_complexity(n_values, theoretical_time):
    plt.plot(n_values, theoretical_time, marker='o')
    plt.xlabel('n (Size of Puzzle)')
    plt.ylabel('Theoretical Time (s)')
    plt.title('Theoretical Time Complexity of ID for n-Puzzle')
    plt.grid(True)
    plt.show()

# Function to plot practical execution time of ID for n-Queens
def plot_practical_execution_time(n_values, execution_time):
    plt.plot(n_values, execution_time, marker='o', color='r')
    plt.xlabel('n (Size of Queens Board)')
    plt.ylabel('Execution Time (s)')
    plt.title('Practical Execution Time of ID for n-Queens')
    plt.grid(True)
    plt.show()

# Example usage:
# Define the range of values for n
n_values = list(range(4, 9))  # Update the range from 4 to 16
theoretical_time_id = theoretical_time_complexity_id(n_values)  # Theoretical time complexity for ID
execution_time_id = [0.1, 0.3, 0.5, 1.2, 2.5]  # Example execution time for ID, adjust as needed

# Plotting theoretical time complexity of ID for n-Puzzle
plot_theoretical_time_complexity(n_values, theoretical_time_id)

# Plotting practical execution time of ID for n-Queens
plot_practical_execution_time(n_values, execution_time_id)

"""........"""

