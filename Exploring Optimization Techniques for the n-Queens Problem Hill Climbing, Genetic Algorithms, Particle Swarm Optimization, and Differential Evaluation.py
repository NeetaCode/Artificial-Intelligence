# -*- coding: utf-8 -*-
"""AI_HW2_CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cOJYm7xcXDxztSF2SqtVpQu3_RsozSZQ
"""

def conflicts(state):
    """
    Counts the number of conflicts in the given state.
    """
    n = len(state)
    conflicts = 0
    for i in range(n):
        for j in range(i + 1, n):
            # Check if queens in positions i and j threaten each other
            if state[i] == state[j] or abs(state[i] - state[j]) == abs(i - j):
                conflicts += 1
    return conflicts

def fitness(state):
    """
    Calculates the fitness score of the given state.
    """
    n = len(state)
    max_fitness = n * (n - 1) // 2  # Maximum possible number of non-attacking pairs
    return max_fitness - conflicts(state)

# Example usage:
n = 8  # Size of the chessboard (8x8 for classic n-queens)
example_state = [0, 1, 2, 3, 4, 5, 6, 7]  # Example state
print("Number of conflicts:", conflicts(example_state))
print("Fitness score:", fitness(example_state))

"""Hill Climging Algorithm with 2 evaluation functions conflict and fitness"""

import random
import time

def is_safe(board, row, col):
    """
    Check if placing a queen at the given position is safe.
    """
    for r, c in enumerate(board):
        if c == col or abs(row - r) == abs(col - c):
            return False
    return True

def successors_fn(state, n):
    """
    Generate successor states from the given state.
    """
    row = len(state)
    successors = []
    for col in range(n):
        if is_safe(state, row, col):
            successors.append(state[:row] + [col])  # Replace the last row with the new column
    return successors

def random_restart_hill_climbing_with_eval(n, evaluation_function, max_iterations=1000, max_iterations_without_improvement=100):
    """
    Hill-climbing algorithm with random restarts to solve the n-queens problem using evaluation function.
    """
    start_time = time.time()
    best_solution = None
    best_fitness = -1
    iterations_without_improvement = 0

    for _ in range(max_iterations):
        # Randomly initialize the state
        current_state = [random.randint(0, n-1) for _ in range(n)]
        current_fitness = evaluation_function(current_state)
        for _ in range(max_iterations_without_improvement):
            successor_states = successors_fn(current_state, n)
            if not successor_states:
                break  # Reached a local optimum
            # Choose the successor with the highest fitness
            next_state = max(successor_states, key=evaluation_function)
            next_fitness = evaluation_function(next_state)
            if next_fitness <= current_fitness:
                break  # Reached a local optimum
            current_state = next_state
            current_fitness = next_fitness
        else:
            break  # No improvement for too many iterations, terminate

        # Update the best solution if applicable
        if current_fitness > best_fitness:
            best_solution = current_state
            best_fitness = current_fitness
            iterations_without_improvement = 0
            if best_fitness == n * (n - 1) // 2:
                break  # Found the global optimum
        else:
            iterations_without_improvement += 1
            if iterations_without_improvement >= max_iterations_without_improvement:
                break  # No improvement for too many iterations, terminate

    end_time = time.time()
    execution_time = end_time - start_time

    return best_solution, best_fitness, execution_time

# Example usage:
n = 80
solution, fitness_score, execution_time = random_restart_hill_climbing_with_eval(n, fitness)
print("Solution:", solution)
print("Fitness score:", fitness_score)
print("Execution time:", execution_time, "seconds")

import random

def is_safe(board, row, col):
    """
    Check if placing a queen at the given position is safe.
    """
    for r, c in enumerate(board):
        if c == col or abs(row - r) == abs(col - c):
            return False
    return True

def random_chromosome(n):
    """
    Generate a random chromosome representing a valid placement of queens.
    """
    return [random.randint(0, n-1) for _ in range(n)]

def crossover(parent1, parent2):
    """
    Perform crossover (recombination) between two parents.
    """
    crossover_point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:crossover_point] + parent2[crossover_point:]
    child2 = parent2[:crossover_point] + parent1[crossover_point:]
    return child1, child2

def mutate(chromosome):
    """
    Mutate a chromosome by randomly changing one gene.
    """
    mutated_chromosome = chromosome[:]
    mutated_index = random.randint(0, len(chromosome) - 1)
    mutated_chromosome[mutated_index] = random.randint(0, len(chromosome) - 1)
    return mutated_chromosome

def fitness(chromosome):
    """
    Evaluate the fitness of a chromosome.
    """
    n = len(chromosome)
    conflicts = 0
    for i in range(n):
        for j in range(i + 1, n):
            if chromosome[i] == chromosome[j] or abs(chromosome[i] - chromosome[j]) == abs(i - j):
                conflicts += 1
    max_fitness = n * (n - 1) // 2
    return max_fitness - conflicts

def genetic_algorithm(n, population_size=100, mutation_rate=0.1, max_generations=1000):
    """
    Genetic algorithm to solve the n-queens problem.
    """
    population = [random_chromosome(n) for _ in range(population_size)]
    for generation in range(max_generations):
        # Evaluate fitness of each chromosome
        fitness_scores = [fitness(chromosome) for chromosome in population]
        # Check if solution found
        if max(fitness_scores) == n * (n - 1) // 2:
            return population[fitness_scores.index(max(fitness_scores))]
        # Select parents for reproduction
        selected_parents = random.choices(population, weights=fitness_scores, k=population_size)
        # Create offspring through crossover
        offspring = []
        for i in range(0, population_size, 2):
            child1, child2 = crossover(selected_parents[i], selected_parents[i + 1])
            offspring.append(child1)
            offspring.append(child2)
        # Mutate offspring
        for i in range(len(offspring)):
            if random.random() < mutation_rate:
                offspring[i] = mutate(offspring[i])
        # Replace old population with offspring
        population = offspring
    return None  # No solution found within max generations

# Example usage:
n = 9
solution = genetic_algorithm(n)
if solution:
    print("Solution found:", solution)
else:
    print("No solution found within the maximum number of generations.")

import random
import numpy as np

class Particle:
    def __init__(self, n):
        self.position = [random.randint(0, n-1) for _ in range(n)]
        self.velocity = [random.uniform(-1, 1) for _ in range(n)]
        self.best_position = self.position.copy()

def fitness(position):
    """
    Evaluate the fitness of a particle's position.
    """
    n = len(position)
    conflicts = 0
    for i in range(n):
        for j in range(i + 1, n):
            if position[i] == position[j] or abs(position[i] - position[j]) == abs(i - j):
                conflicts += 1
    max_fitness = n * (n - 1) // 2
    return max_fitness - conflicts

def update_velocity(particle, global_best_position, inertia_weight, cognitive_param, social_param):
    """
    Update the velocity of a particle.
    """
    for i in range(len(particle.velocity)):
        cognitive_component = cognitive_param * random.random() * (particle.best_position[i] - particle.position[i])
        social_component = social_param * random.random() * (global_best_position[i] - particle.position[i])
        particle.velocity[i] = inertia_weight * particle.velocity[i] + cognitive_component + social_component

def update_position(particle):
    """
    Update the position of a particle based on its velocity.
    """
    for i in range(len(particle.position)):
        new_position = round(particle.position[i] + particle.velocity[i])
        particle.position[i] = max(0, min(new_position, len(particle.position) - 1))

def pso(n, swarm_size=100, max_iterations=1000, inertia_weight=0.9, cognitive_param=2, social_param=2):
    """
    Particle Swarm Optimization (PSO) algorithm to solve the n-queens problem.
    """
    swarm = [Particle(n) for _ in range(swarm_size)]
    global_best_position = min(swarm, key=lambda x: fitness(x.position)).position
    for _ in range(max_iterations):
        for particle in swarm:
            if fitness(particle.position) > fitness(particle.best_position):
                particle.best_position = particle.position.copy()
            if fitness(particle.position) > fitness(global_best_position):
                global_best_position = particle.position.copy()
        for particle in swarm:
            update_velocity(particle, global_best_position, inertia_weight, cognitive_param, social_param)
            update_position(particle)
    return global_best_position

# Example usage:
n = 80
solution = pso(n)
print("Solution found:", solution)

"""DE"""

import random
import numpy as np

def initialize_population(pop_size, n):
    """
    Initialize the population of chromosomes.
    """
    population = []
    for _ in range(pop_size):
        chromosome = [random.randint(0, n-1) for _ in range(n)]
        population.append(chromosome)
    return population

def mutation(population, F):
    """
    Mutation operation to create new candidate solutions.
    """
    mutant_population = []
    for target in population:
        r1, r2, r3 = random.sample(population, 3)
        mutant = [target[i] + F * (r1[i] - r2[i]) + F * (r3[i] - target[i]) for i in range(len(target))]
        mutant = [int(max(0, min(val, len(target) - 1))) for val in mutant]
        mutant_population.append(mutant)
    return mutant_population

def crossover(population, mutant_population, CR):
    """
    Crossover operation to create offspring solutions.
    """
    offspring_population = []
    for i in range(len(population)):
        offspring = []
        for j in range(len(population[i])):
            if random.random() < CR:
                offspring.append(mutant_population[i][j])
            else:
                offspring.append(population[i][j])
        offspring_population.append(offspring)
    return offspring_population

def select_population(population, offspring_population, fitness_fn):
    """
    Selection operation to choose individuals for the next generation.
    """
    new_population = []
    for i in range(len(population)):
        if fitness_fn(offspring_population[i]) >= fitness_fn(population[i]):
            new_population.append(offspring_population[i])
        else:
            new_population.append(population[i])
    return new_population

def fitness(chromosome):
    """
    Evaluate the fitness of a chromosome's position.
    """
    n = len(chromosome)
    conflicts = 0
    for i in range(n):
        for j in range(i + 1, n):
            if chromosome[i] == chromosome[j] or abs(chromosome[i] - chromosome[j]) == abs(i - j):
                conflicts += 1
    max_fitness = n * (n - 1) // 2
    return max_fitness - conflicts

def de(pop_size, n, max_iterations, F=0.5, CR=0.8):
    """
    Differential Evolution (DE) algorithm to solve the n-queens problem.
    """
    population = initialize_population(pop_size, n)
    for _ in range(max_iterations):
        mutant_population = mutation(population, F)
        offspring_population = crossover(population, mutant_population, CR)
        population = select_population(population, offspring_population, fitness)
    best_chromosome = max(population, key=fitness)
    return best_chromosome

# Example usage:
pop_size = 100
n = 80
max_iterations = 1000
solution = de(pop_size, n, max_iterations)
print("Solution found:", solution)